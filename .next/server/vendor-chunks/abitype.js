"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/abitype";
exports.ids = ["vendor-chunks/abitype"];
exports.modules = {

/***/ "(ssr)/./node_modules/abitype/dist/chunk-NHABU752.mjs":
/*!******************************************************!*\
  !*** ./node_modules/abitype/dist/chunk-NHABU752.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __publicField: () => (/* binding */ __publicField)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2NodW5rLU5IQUJVNzUyLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0E7QUFDQTtBQUNBOztBQUlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2NodW5rLU5IQUJVNzUyLm1qcz85YzdkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuZXhwb3J0IHtcbiAgX19wdWJsaWNGaWVsZFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/abitype/dist/chunk-NHABU752.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/abitype/dist/chunk-WP7KDV47.mjs":
/*!******************************************************!*\
  !*** ./node_modules/abitype/dist/chunk-WP7KDV47.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bytesRegex: () => (/* binding */ bytesRegex),\n/* harmony export */   execTyped: () => (/* binding */ execTyped),\n/* harmony export */   integerRegex: () => (/* binding */ integerRegex),\n/* harmony export */   isTupleRegex: () => (/* binding */ isTupleRegex)\n/* harmony export */ });\n// src/regex.ts\nfunction execTyped(regex, string) {\n  const match = regex.exec(string);\n  return match?.groups;\n}\nvar bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\nvar integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nvar isTupleRegex = /^\\(.+?\\).*?$/;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2NodW5rLVdQN0tEVjQ3Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFPRSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9jaHVuay1XUDdLRFY0Ny5tanM/NTVhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcmVnZXgudHNcbmZ1bmN0aW9uIGV4ZWNUeXBlZChyZWdleCwgc3RyaW5nKSB7XG4gIGNvbnN0IG1hdGNoID0gcmVnZXguZXhlYyhzdHJpbmcpO1xuICByZXR1cm4gbWF0Y2g/Lmdyb3Vwcztcbn1cbnZhciBieXRlc1JlZ2V4ID0gL15ieXRlcyhbMS05XXwxWzAtOV18MlswLTldfDNbMC0yXSk/JC87XG52YXIgaW50ZWdlclJlZ2V4ID0gL151P2ludCg4fDE2fDI0fDMyfDQwfDQ4fDU2fDY0fDcyfDgwfDg4fDk2fDEwNHwxMTJ8MTIwfDEyOHwxMzZ8MTQ0fDE1MnwxNjB8MTY4fDE3NnwxODR8MTkyfDIwMHwyMDh8MjE2fDIyNHwyMzJ8MjQwfDI0OHwyNTYpPyQvO1xudmFyIGlzVHVwbGVSZWdleCA9IC9eXFwoLis/XFwpLio/JC87XG5cbmV4cG9ydCB7XG4gIGV4ZWNUeXBlZCxcbiAgYnl0ZXNSZWdleCxcbiAgaW50ZWdlclJlZ2V4LFxuICBpc1R1cGxlUmVnZXhcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/abitype/dist/chunk-WP7KDV47.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/abitype/dist/index.mjs":
/*!*********************************************!*\
  !*** ./node_modules/abitype/dist/index.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseError: () => (/* binding */ BaseError),\n/* harmony export */   narrow: () => (/* binding */ narrow),\n/* harmony export */   parseAbi: () => (/* binding */ parseAbi),\n/* harmony export */   parseAbiItem: () => (/* binding */ parseAbiItem),\n/* harmony export */   parseAbiParameter: () => (/* binding */ parseAbiParameter2),\n/* harmony export */   parseAbiParameters: () => (/* binding */ parseAbiParameters)\n/* harmony export */ });\n/* harmony import */ var _chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-WP7KDV47.mjs */ \"(ssr)/./node_modules/abitype/dist/chunk-WP7KDV47.mjs\");\n/* harmony import */ var _chunk_NHABU752_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-NHABU752.mjs */ \"(ssr)/./node_modules/abitype/dist/chunk-NHABU752.mjs\");\n\n\n\n// package.json\nvar name = \"abitype\";\nvar version = \"0.7.1\";\n\n// src/errors.ts\nvar BaseError = class extends Error {\n  constructor(shortMessage, args = {}) {\n    const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;\n    const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;\n    const message = [\n      shortMessage || \"An error occurred.\",\n      \"\",\n      ...args.metaMessages ? [...args.metaMessages, \"\"] : [],\n      ...docsPath ? [`Docs: https://abitype.dev${docsPath}`] : [],\n      ...details ? [`Details: ${details}`] : [],\n      `Version: ${name}@${version}`\n    ].join(\"\\n\");\n    super(message);\n    (0,_chunk_NHABU752_mjs__WEBPACK_IMPORTED_MODULE_0__.__publicField)(this, \"details\");\n    (0,_chunk_NHABU752_mjs__WEBPACK_IMPORTED_MODULE_0__.__publicField)(this, \"docsPath\");\n    (0,_chunk_NHABU752_mjs__WEBPACK_IMPORTED_MODULE_0__.__publicField)(this, \"metaMessages\");\n    (0,_chunk_NHABU752_mjs__WEBPACK_IMPORTED_MODULE_0__.__publicField)(this, \"shortMessage\");\n    (0,_chunk_NHABU752_mjs__WEBPACK_IMPORTED_MODULE_0__.__publicField)(this, \"name\", \"AbiTypeError\");\n    if (args.cause)\n      this.cause = args.cause;\n    this.details = details;\n    this.docsPath = docsPath;\n    this.metaMessages = args.metaMessages;\n    this.shortMessage = shortMessage;\n  }\n};\n\n// src/narrow.ts\nfunction narrow(value) {\n  return value;\n}\n\n// src/human-readable/runtime/signatures.ts\nvar errorSignatureRegex = /^error (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)$/;\nfunction isErrorSignature(signature) {\n  return errorSignatureRegex.test(signature);\n}\nfunction execErrorSignature(signature) {\n  return (0,_chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.execTyped)(\n    errorSignatureRegex,\n    signature\n  );\n}\nvar eventSignatureRegex = /^event (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)$/;\nfunction isEventSignature(signature) {\n  return eventSignatureRegex.test(signature);\n}\nfunction execEventSignature(signature) {\n  return (0,_chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.execTyped)(\n    eventSignatureRegex,\n    signature\n  );\n}\nvar functionSignatureRegex = /^function (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns \\((?<returns>.*?)\\))?$/;\nfunction isFunctionSignature(signature) {\n  return functionSignatureRegex.test(signature);\n}\nfunction execFunctionSignature(signature) {\n  return (0,_chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.execTyped)(functionSignatureRegex, signature);\n}\nvar structSignatureRegex = /^struct (?<name>[a-zA-Z0-9_]+) \\{(?<properties>.*?)\\}$/;\nfunction isStructSignature(signature) {\n  return structSignatureRegex.test(signature);\n}\nfunction execStructSignature(signature) {\n  return (0,_chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.execTyped)(\n    structSignatureRegex,\n    signature\n  );\n}\nvar constructorSignatureRegex = /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/;\nfunction isConstructorSignature(signature) {\n  return constructorSignatureRegex.test(signature);\n}\nfunction execConstructorSignature(signature) {\n  return (0,_chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.execTyped)(constructorSignatureRegex, signature);\n}\nvar fallbackSignatureRegex = /^fallback\\(\\)$/;\nfunction isFallbackSignature(signature) {\n  return fallbackSignatureRegex.test(signature);\n}\nvar receiveSignatureRegex = /^receive\\(\\) external payable$/;\nfunction isReceiveSignature(signature) {\n  return receiveSignatureRegex.test(signature);\n}\nvar modifiers = /* @__PURE__ */ new Set([\n  \"memory\",\n  \"indexed\",\n  \"storage\",\n  \"calldata\"\n]);\nvar eventModifiers = /* @__PURE__ */ new Set([\"indexed\"]);\nvar functionModifiers = /* @__PURE__ */ new Set([\n  \"calldata\",\n  \"memory\",\n  \"storage\"\n]);\n\n// src/human-readable/runtime/cache.ts\nfunction getParameterCacheKey(param, type) {\n  if (type)\n    return `${type}:${param}`;\n  return param;\n}\nvar parameterCache = /* @__PURE__ */ new Map([\n  // Unnamed\n  [\"address\", { type: \"address\" }],\n  [\"bool\", { type: \"bool\" }],\n  [\"bytes\", { type: \"bytes\" }],\n  [\"bytes32\", { type: \"bytes32\" }],\n  [\"int\", { type: \"int256\" }],\n  [\"int256\", { type: \"int256\" }],\n  [\"string\", { type: \"string\" }],\n  [\"uint\", { type: \"uint256\" }],\n  [\"uint8\", { type: \"uint8\" }],\n  [\"uint16\", { type: \"uint16\" }],\n  [\"uint24\", { type: \"uint24\" }],\n  [\"uint32\", { type: \"uint32\" }],\n  [\"uint64\", { type: \"uint64\" }],\n  [\"uint96\", { type: \"uint96\" }],\n  [\"uint112\", { type: \"uint112\" }],\n  [\"uint160\", { type: \"uint160\" }],\n  [\"uint192\", { type: \"uint192\" }],\n  [\"uint256\", { type: \"uint256\" }],\n  // Named\n  [\"address owner\", { type: \"address\", name: \"owner\" }],\n  [\"address to\", { type: \"address\", name: \"to\" }],\n  [\"bool approved\", { type: \"bool\", name: \"approved\" }],\n  [\"bytes _data\", { type: \"bytes\", name: \"_data\" }],\n  [\"bytes data\", { type: \"bytes\", name: \"data\" }],\n  [\"bytes signature\", { type: \"bytes\", name: \"signature\" }],\n  [\"bytes32 hash\", { type: \"bytes32\", name: \"hash\" }],\n  [\"bytes32 r\", { type: \"bytes32\", name: \"r\" }],\n  [\"bytes32 root\", { type: \"bytes32\", name: \"root\" }],\n  [\"bytes32 s\", { type: \"bytes32\", name: \"s\" }],\n  [\"string name\", { type: \"string\", name: \"name\" }],\n  [\"string symbol\", { type: \"string\", name: \"symbol\" }],\n  [\"string tokenURI\", { type: \"string\", name: \"tokenURI\" }],\n  [\"uint tokenId\", { type: \"uint256\", name: \"tokenId\" }],\n  [\"uint8 v\", { type: \"uint8\", name: \"v\" }],\n  [\"uint256 balance\", { type: \"uint256\", name: \"balance\" }],\n  [\"uint256 tokenId\", { type: \"uint256\", name: \"tokenId\" }],\n  [\"uint256 value\", { type: \"uint256\", name: \"value\" }],\n  // Indexed\n  [\n    \"event:address indexed from\",\n    { type: \"address\", name: \"from\", indexed: true }\n  ],\n  [\"event:address indexed to\", { type: \"address\", name: \"to\", indexed: true }],\n  [\n    \"event:uint indexed tokenId\",\n    { type: \"uint256\", name: \"tokenId\", indexed: true }\n  ],\n  [\n    \"event:uint256 indexed tokenId\",\n    { type: \"uint256\", name: \"tokenId\", indexed: true }\n  ]\n]);\n\n// src/human-readable/runtime/utils.ts\nfunction parseSignature(signature, structs = {}) {\n  if (isFunctionSignature(signature)) {\n    const match = execFunctionSignature(signature);\n    if (!match)\n      throw new BaseError(\"Invalid function signature.\", {\n        details: signature\n      });\n    const inputParams = splitParameters(match.parameters);\n    const inputs = [];\n    const inputLength = inputParams.length;\n    for (let i = 0; i < inputLength; i++) {\n      inputs.push(\n        parseAbiParameter(inputParams[i], {\n          modifiers: functionModifiers,\n          structs,\n          type: \"function\"\n        })\n      );\n    }\n    const outputs = [];\n    if (match.returns) {\n      const outputParams = splitParameters(match.returns);\n      const outputLength = outputParams.length;\n      for (let i = 0; i < outputLength; i++) {\n        outputs.push(\n          parseAbiParameter(outputParams[i], {\n            modifiers: functionModifiers,\n            structs,\n            type: \"function\"\n          })\n        );\n      }\n    }\n    return {\n      name: match.name,\n      type: \"function\",\n      stateMutability: match.stateMutability ?? \"nonpayable\",\n      inputs,\n      outputs\n    };\n  }\n  if (isEventSignature(signature)) {\n    const match = execEventSignature(signature);\n    if (!match)\n      throw new BaseError(\"Invalid event signature.\", {\n        details: signature\n      });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i], {\n          modifiers: eventModifiers,\n          structs,\n          type: \"event\"\n        })\n      );\n    }\n    return { name: match.name, type: \"event\", inputs: abiParameters };\n  }\n  if (isErrorSignature(signature)) {\n    const match = execErrorSignature(signature);\n    if (!match)\n      throw new BaseError(\"Invalid error signature.\", {\n        details: signature\n      });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i], { structs, type: \"error\" })\n      );\n    }\n    return { name: match.name, type: \"error\", inputs: abiParameters };\n  }\n  if (isConstructorSignature(signature)) {\n    const match = execConstructorSignature(signature);\n    if (!match)\n      throw new BaseError(\"Invalid constructor signature.\", {\n        details: signature\n      });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i], { structs, type: \"constructor\" })\n      );\n    }\n    return {\n      type: \"constructor\",\n      stateMutability: match.stateMutability ?? \"nonpayable\",\n      inputs: abiParameters\n    };\n  }\n  if (isFallbackSignature(signature))\n    return { type: \"fallback\" };\n  if (isReceiveSignature(signature))\n    return {\n      type: \"receive\",\n      stateMutability: \"payable\"\n    };\n  throw new BaseError(\"Unknown signature.\", {\n    details: signature\n  });\n}\nvar abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z0-9_]+))?$/;\nvar abiParameterWithTupleRegex = /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z0-9_]+))?$/;\nvar dynamicIntegerRegex = /^u?int$/;\nfunction parseAbiParameter(param, options) {\n  const parameterCacheKey = getParameterCacheKey(param, options?.type);\n  if (parameterCache.has(parameterCacheKey))\n    return parameterCache.get(parameterCacheKey);\n  const isTuple = _chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.isTupleRegex.test(param);\n  const match = (0,_chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.execTyped)(\n    isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex,\n    param\n  );\n  if (!match)\n    throw new BaseError(\"Invalid ABI parameter.\", {\n      details: param\n    });\n  if (match.name && isSolidityKeyword(match.name))\n    throw new BaseError(\"Invalid ABI parameter.\", {\n      details: param,\n      metaMessages: [\n        `\"${match.name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`\n      ]\n    });\n  const name2 = match.name ? { name: match.name } : {};\n  const indexed = match.modifier === \"indexed\" ? { indexed: true } : {};\n  const structs = options?.structs ?? {};\n  let type;\n  let components = {};\n  if (isTuple) {\n    type = \"tuple\";\n    const params = splitParameters(match.type);\n    const components_ = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      components_.push(parseAbiParameter(params[i], { structs }));\n    }\n    components = { components: components_ };\n  } else if (match.type in structs) {\n    type = \"tuple\";\n    components = { components: structs[match.type] };\n  } else if (dynamicIntegerRegex.test(match.type)) {\n    type = `${match.type}256`;\n  } else {\n    type = match.type;\n    if (!(options?.type === \"struct\") && !isSolidityType(type))\n      throw new BaseError(\"Unknown type.\", {\n        metaMessages: [`Type \"${type}\" is not a valid ABI type.`]\n      });\n  }\n  if (match.modifier) {\n    if (!options?.modifiers?.has?.(match.modifier))\n      throw new BaseError(\"Invalid ABI parameter.\", {\n        details: param,\n        metaMessages: [\n          `Modifier \"${match.modifier}\" not allowed${options?.type ? ` in \"${options.type}\" type` : \"\"}.`\n        ]\n      });\n    if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))\n      throw new BaseError(\"Invalid ABI parameter.\", {\n        details: param,\n        metaMessages: [\n          `Modifier \"${match.modifier}\" not allowed${options?.type ? ` in \"${options.type}\" type` : \"\"}.`,\n          `Data location can only be specified for array, struct, or mapping types, but \"${match.modifier}\" was given.`\n        ]\n      });\n  }\n  const abiParameter = {\n    type: `${type}${match.array ?? \"\"}`,\n    ...name2,\n    ...indexed,\n    ...components\n  };\n  parameterCache.set(parameterCacheKey, abiParameter);\n  return abiParameter;\n}\nfunction splitParameters(params, result = [], current = \"\", depth = 0) {\n  if (params === \"\") {\n    if (current === \"\")\n      return result;\n    if (depth !== 0)\n      throw new BaseError(\"Unbalanced parentheses.\", {\n        metaMessages: [\n          `\"${current.trim()}\" has too many ${depth > 0 ? \"opening\" : \"closing\"} parentheses.`\n        ],\n        details: `Depth \"${depth}\"`\n      });\n    return [...result, current.trim()];\n  }\n  const length = params.length;\n  for (let i = 0; i < length; i++) {\n    const char = params[i];\n    const tail = params.slice(i + 1);\n    switch (char) {\n      case \",\":\n        return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);\n      case \"(\":\n        return splitParameters(tail, result, `${current}${char}`, depth + 1);\n      case \")\":\n        return splitParameters(tail, result, `${current}${char}`, depth - 1);\n      default:\n        return splitParameters(tail, result, `${current}${char}`, depth);\n    }\n  }\n  return [];\n}\nfunction isSolidityType(type) {\n  return type === \"address\" || type === \"bool\" || type === \"function\" || type === \"string\" || _chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.bytesRegex.test(type) || _chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.integerRegex.test(type);\n}\nvar protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\nfunction isSolidityKeyword(name2) {\n  return name2 === \"address\" || name2 === \"bool\" || name2 === \"function\" || name2 === \"string\" || name2 === \"tuple\" || _chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.bytesRegex.test(name2) || _chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.integerRegex.test(name2) || protectedKeywordsRegex.test(name2);\n}\nfunction isValidDataLocation(type, isArray) {\n  return isArray || type === \"bytes\" || type === \"string\" || type === \"tuple\";\n}\n\n// src/human-readable/runtime/structs.ts\nfunction parseStructs(signatures) {\n  const shallowStructs = {};\n  const signaturesLength = signatures.length;\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i];\n    if (!isStructSignature(signature))\n      continue;\n    const match = execStructSignature(signature);\n    if (!match)\n      throw new BaseError(\"Invalid struct signature.\", {\n        details: signature\n      });\n    const properties = match.properties.split(\";\");\n    const components = [];\n    const propertiesLength = properties.length;\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k];\n      const trimmed = property.trim();\n      if (!trimmed)\n        continue;\n      const abiParameter = parseAbiParameter(trimmed, {\n        type: \"struct\"\n      });\n      components.push(abiParameter);\n    }\n    if (!components.length)\n      throw new BaseError(\"Invalid struct signature.\", {\n        details: signature,\n        metaMessages: [\"No properties exist.\"]\n      });\n    shallowStructs[match.name] = components;\n  }\n  const resolvedStructs = {};\n  const entries = Object.entries(shallowStructs);\n  const entriesLength = entries.length;\n  for (let i = 0; i < entriesLength; i++) {\n    const [name2, parameters] = entries[i];\n    resolvedStructs[name2] = resolveStructs(parameters, shallowStructs);\n  }\n  return resolvedStructs;\n}\nvar typeWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\\[\\d*?\\])+?)?$/;\nfunction resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */ new Set()) {\n  const components = [];\n  const length = abiParameters.length;\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i];\n    const isTuple = _chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.isTupleRegex.test(abiParameter.type);\n    if (isTuple)\n      components.push(abiParameter);\n    else {\n      const match = (0,_chunk_WP7KDV47_mjs__WEBPACK_IMPORTED_MODULE_1__.execTyped)(\n        typeWithoutTupleRegex,\n        abiParameter.type\n      );\n      if (!match?.type)\n        throw new BaseError(\"Invalid ABI parameter.\", {\n          details: JSON.stringify(abiParameter, null, 2),\n          metaMessages: [\"ABI parameter type is invalid.\"]\n        });\n      const { array, type } = match;\n      if (type in structs) {\n        if (ancestors.has(type))\n          throw new BaseError(\"Circular reference detected.\", {\n            metaMessages: [`Struct \"${type}\" is a circular reference.`]\n          });\n        components.push({\n          ...abiParameter,\n          type: `tuple${array ?? \"\"}`,\n          components: resolveStructs(\n            structs[type] ?? [],\n            structs,\n            /* @__PURE__ */ new Set([...ancestors, type])\n          )\n        });\n      } else {\n        if (isSolidityType(type))\n          components.push(abiParameter);\n        else\n          throw new BaseError(\"Unknown type.\", {\n            metaMessages: [\n              `Type \"${type}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`\n            ]\n          });\n      }\n    }\n  }\n  return components;\n}\n\n// src/human-readable/parseAbi.ts\nfunction parseAbi(signatures) {\n  const structs = parseStructs(signatures);\n  const abi = [];\n  const length = signatures.length;\n  for (let i = 0; i < length; i++) {\n    const signature = signatures[i];\n    if (isStructSignature(signature))\n      continue;\n    abi.push(parseSignature(signature, structs));\n  }\n  return abi;\n}\n\n// src/human-readable/parseAbiItem.ts\nfunction parseAbiItem(signature) {\n  let abiItem;\n  if (typeof signature === \"string\")\n    abiItem = parseSignature(signature);\n  else {\n    const structs = parseStructs(signature);\n    const length = signature.length;\n    for (let i = 0; i < length; i++) {\n      const signature_ = signature[i];\n      if (isStructSignature(signature_))\n        continue;\n      abiItem = parseSignature(signature_, structs);\n      break;\n    }\n  }\n  if (!abiItem)\n    throw new BaseError(\"Failed to parse ABI item.\", {\n      details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,\n      docsPath: \"/api/human.html#parseabiitem-1\"\n    });\n  return abiItem;\n}\n\n// src/human-readable/parseAbiParameter.ts\nfunction parseAbiParameter2(param) {\n  let abiParameter;\n  if (typeof param === \"string\")\n    abiParameter = parseAbiParameter(param, {\n      modifiers\n    });\n  else {\n    const structs = parseStructs(param);\n    const length = param.length;\n    for (let i = 0; i < length; i++) {\n      const signature = param[i];\n      if (isStructSignature(signature))\n        continue;\n      abiParameter = parseAbiParameter(signature, { modifiers, structs });\n      break;\n    }\n  }\n  if (!abiParameter)\n    throw new BaseError(\"Failed to parse ABI parameter.\", {\n      details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,\n      docsPath: \"/api/human.html#parseabiparameter-1\"\n    });\n  return abiParameter;\n}\n\n// src/human-readable/parseAbiParameters.ts\nfunction parseAbiParameters(params) {\n  const abiParameters = [];\n  if (typeof params === \"string\") {\n    const parameters = splitParameters(params);\n    const length = parameters.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter(parameters[i], { modifiers }));\n    }\n  } else {\n    const structs = parseStructs(params);\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      const signature = params[i];\n      if (isStructSignature(signature))\n        continue;\n      const parameters = splitParameters(signature);\n      const length2 = parameters.length;\n      for (let k = 0; k < length2; k++) {\n        abiParameters.push(\n          parseAbiParameter(parameters[k], { modifiers, structs })\n        );\n      }\n    }\n  }\n  if (abiParameters.length === 0)\n    throw new BaseError(\"Failed to parse ABI parameters.\", {\n      details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,\n      docsPath: \"/api/human.html#parseabiparameters-1\"\n    });\n  return abiParameters;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUs4QjtBQUdBOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRCxnQ0FBZ0MsUUFBUTtBQUN4QyxrQkFBa0IsS0FBSyxHQUFHLFFBQVE7QUFDbEM7QUFDQTtBQUNBLElBQUksa0VBQWE7QUFDakIsSUFBSSxrRUFBYTtBQUNqQixJQUFJLGtFQUFhO0FBQ2pCLElBQUksa0VBQWE7QUFDakIsSUFBSSxrRUFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOERBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlIQUFpSCxFQUFFLHVEQUF1RCxFQUFFO0FBQzVLO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBUztBQUNsQjtBQUNBLDZEQUE2RCxvQkFBb0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLEVBQUU7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUssR0FBRyxNQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JB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Q25FO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMsNERBQTRELFdBQVc7QUFDdkU7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBLDZDQUE2QyxvQkFBb0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdDQUFnQztBQUNyRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBUUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvaW5kZXgubWpzPzViNGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgYnl0ZXNSZWdleCxcbiAgZXhlY1R5cGVkLFxuICBpbnRlZ2VyUmVnZXgsXG4gIGlzVHVwbGVSZWdleFxufSBmcm9tIFwiLi9jaHVuay1XUDdLRFY0Ny5tanNcIjtcbmltcG9ydCB7XG4gIF9fcHVibGljRmllbGRcbn0gZnJvbSBcIi4vY2h1bmstTkhBQlU3NTIubWpzXCI7XG5cbi8vIHBhY2thZ2UuanNvblxudmFyIG5hbWUgPSBcImFiaXR5cGVcIjtcbnZhciB2ZXJzaW9uID0gXCIwLjcuMVwiO1xuXG4vLyBzcmMvZXJyb3JzLnRzXG52YXIgQmFzZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNob3J0TWVzc2FnZSwgYXJncyA9IHt9KSB7XG4gICAgY29uc3QgZGV0YWlscyA9IGFyZ3MuY2F1c2UgaW5zdGFuY2VvZiBCYXNlRXJyb3IgPyBhcmdzLmNhdXNlLmRldGFpbHMgOiBhcmdzLmNhdXNlPy5tZXNzYWdlID8gYXJncy5jYXVzZS5tZXNzYWdlIDogYXJncy5kZXRhaWxzO1xuICAgIGNvbnN0IGRvY3NQYXRoID0gYXJncy5jYXVzZSBpbnN0YW5jZW9mIEJhc2VFcnJvciA/IGFyZ3MuY2F1c2UuZG9jc1BhdGggfHwgYXJncy5kb2NzUGF0aCA6IGFyZ3MuZG9jc1BhdGg7XG4gICAgY29uc3QgbWVzc2FnZSA9IFtcbiAgICAgIHNob3J0TWVzc2FnZSB8fCBcIkFuIGVycm9yIG9jY3VycmVkLlwiLFxuICAgICAgXCJcIixcbiAgICAgIC4uLmFyZ3MubWV0YU1lc3NhZ2VzID8gWy4uLmFyZ3MubWV0YU1lc3NhZ2VzLCBcIlwiXSA6IFtdLFxuICAgICAgLi4uZG9jc1BhdGggPyBbYERvY3M6IGh0dHBzOi8vYWJpdHlwZS5kZXYke2RvY3NQYXRofWBdIDogW10sXG4gICAgICAuLi5kZXRhaWxzID8gW2BEZXRhaWxzOiAke2RldGFpbHN9YF0gOiBbXSxcbiAgICAgIGBWZXJzaW9uOiAke25hbWV9QCR7dmVyc2lvbn1gXG4gICAgXS5qb2luKFwiXFxuXCIpO1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkZXRhaWxzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkb2NzUGF0aFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWV0YU1lc3NhZ2VzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzaG9ydE1lc3NhZ2VcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm5hbWVcIiwgXCJBYmlUeXBlRXJyb3JcIik7XG4gICAgaWYgKGFyZ3MuY2F1c2UpXG4gICAgICB0aGlzLmNhdXNlID0gYXJncy5jYXVzZTtcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIHRoaXMuZG9jc1BhdGggPSBkb2NzUGF0aDtcbiAgICB0aGlzLm1ldGFNZXNzYWdlcyA9IGFyZ3MubWV0YU1lc3NhZ2VzO1xuICAgIHRoaXMuc2hvcnRNZXNzYWdlID0gc2hvcnRNZXNzYWdlO1xuICB9XG59O1xuXG4vLyBzcmMvbmFycm93LnRzXG5mdW5jdGlvbiBuYXJyb3codmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBzcmMvaHVtYW4tcmVhZGFibGUvcnVudGltZS9zaWduYXR1cmVzLnRzXG52YXIgZXJyb3JTaWduYXR1cmVSZWdleCA9IC9eZXJyb3IgKD88bmFtZT5bYS16QS1aMC05X10rKVxcKCg/PHBhcmFtZXRlcnM+Lio/KVxcKSQvO1xuZnVuY3Rpb24gaXNFcnJvclNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgcmV0dXJuIGVycm9yU2lnbmF0dXJlUmVnZXgudGVzdChzaWduYXR1cmUpO1xufVxuZnVuY3Rpb24gZXhlY0Vycm9yU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICByZXR1cm4gZXhlY1R5cGVkKFxuICAgIGVycm9yU2lnbmF0dXJlUmVnZXgsXG4gICAgc2lnbmF0dXJlXG4gICk7XG59XG52YXIgZXZlbnRTaWduYXR1cmVSZWdleCA9IC9eZXZlbnQgKD88bmFtZT5bYS16QS1aMC05X10rKVxcKCg/PHBhcmFtZXRlcnM+Lio/KVxcKSQvO1xuZnVuY3Rpb24gaXNFdmVudFNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgcmV0dXJuIGV2ZW50U2lnbmF0dXJlUmVnZXgudGVzdChzaWduYXR1cmUpO1xufVxuZnVuY3Rpb24gZXhlY0V2ZW50U2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICByZXR1cm4gZXhlY1R5cGVkKFxuICAgIGV2ZW50U2lnbmF0dXJlUmVnZXgsXG4gICAgc2lnbmF0dXJlXG4gICk7XG59XG52YXIgZnVuY3Rpb25TaWduYXR1cmVSZWdleCA9IC9eZnVuY3Rpb24gKD88bmFtZT5bYS16QS1aMC05X10rKVxcKCg/PHBhcmFtZXRlcnM+Lio/KVxcKSg/OiAoPzxzY29wZT5leHRlcm5hbHxwdWJsaWN7MX0pKT8oPzogKD88c3RhdGVNdXRhYmlsaXR5PnB1cmV8dmlld3xub25wYXlhYmxlfHBheWFibGV7MX0pKT8oPzogcmV0dXJucyBcXCgoPzxyZXR1cm5zPi4qPylcXCkpPyQvO1xuZnVuY3Rpb24gaXNGdW5jdGlvblNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uU2lnbmF0dXJlUmVnZXgudGVzdChzaWduYXR1cmUpO1xufVxuZnVuY3Rpb24gZXhlY0Z1bmN0aW9uU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICByZXR1cm4gZXhlY1R5cGVkKGZ1bmN0aW9uU2lnbmF0dXJlUmVnZXgsIHNpZ25hdHVyZSk7XG59XG52YXIgc3RydWN0U2lnbmF0dXJlUmVnZXggPSAvXnN0cnVjdCAoPzxuYW1lPlthLXpBLVowLTlfXSspIFxceyg/PHByb3BlcnRpZXM+Lio/KVxcfSQvO1xuZnVuY3Rpb24gaXNTdHJ1Y3RTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gIHJldHVybiBzdHJ1Y3RTaWduYXR1cmVSZWdleC50ZXN0KHNpZ25hdHVyZSk7XG59XG5mdW5jdGlvbiBleGVjU3RydWN0U2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICByZXR1cm4gZXhlY1R5cGVkKFxuICAgIHN0cnVjdFNpZ25hdHVyZVJlZ2V4LFxuICAgIHNpZ25hdHVyZVxuICApO1xufVxudmFyIGNvbnN0cnVjdG9yU2lnbmF0dXJlUmVnZXggPSAvXmNvbnN0cnVjdG9yXFwoKD88cGFyYW1ldGVycz4uKj8pXFwpKD86XFxzKD88c3RhdGVNdXRhYmlsaXR5PnBheWFibGV7MX0pKT8kLztcbmZ1bmN0aW9uIGlzQ29uc3RydWN0b3JTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gIHJldHVybiBjb25zdHJ1Y3RvclNpZ25hdHVyZVJlZ2V4LnRlc3Qoc2lnbmF0dXJlKTtcbn1cbmZ1bmN0aW9uIGV4ZWNDb25zdHJ1Y3RvclNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgcmV0dXJuIGV4ZWNUeXBlZChjb25zdHJ1Y3RvclNpZ25hdHVyZVJlZ2V4LCBzaWduYXR1cmUpO1xufVxudmFyIGZhbGxiYWNrU2lnbmF0dXJlUmVnZXggPSAvXmZhbGxiYWNrXFwoXFwpJC87XG5mdW5jdGlvbiBpc0ZhbGxiYWNrU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICByZXR1cm4gZmFsbGJhY2tTaWduYXR1cmVSZWdleC50ZXN0KHNpZ25hdHVyZSk7XG59XG52YXIgcmVjZWl2ZVNpZ25hdHVyZVJlZ2V4ID0gL15yZWNlaXZlXFwoXFwpIGV4dGVybmFsIHBheWFibGUkLztcbmZ1bmN0aW9uIGlzUmVjZWl2ZVNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgcmV0dXJuIHJlY2VpdmVTaWduYXR1cmVSZWdleC50ZXN0KHNpZ25hdHVyZSk7XG59XG52YXIgbW9kaWZpZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcIm1lbW9yeVwiLFxuICBcImluZGV4ZWRcIixcbiAgXCJzdG9yYWdlXCIsXG4gIFwiY2FsbGRhdGFcIlxuXSk7XG52YXIgZXZlbnRNb2RpZmllcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJpbmRleGVkXCJdKTtcbnZhciBmdW5jdGlvbk1vZGlmaWVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJjYWxsZGF0YVwiLFxuICBcIm1lbW9yeVwiLFxuICBcInN0b3JhZ2VcIlxuXSk7XG5cbi8vIHNyYy9odW1hbi1yZWFkYWJsZS9ydW50aW1lL2NhY2hlLnRzXG5mdW5jdGlvbiBnZXRQYXJhbWV0ZXJDYWNoZUtleShwYXJhbSwgdHlwZSkge1xuICBpZiAodHlwZSlcbiAgICByZXR1cm4gYCR7dHlwZX06JHtwYXJhbX1gO1xuICByZXR1cm4gcGFyYW07XG59XG52YXIgcGFyYW1ldGVyQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIC8vIFVubmFtZWRcbiAgW1wiYWRkcmVzc1wiLCB7IHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICBbXCJib29sXCIsIHsgdHlwZTogXCJib29sXCIgfV0sXG4gIFtcImJ5dGVzXCIsIHsgdHlwZTogXCJieXRlc1wiIH1dLFxuICBbXCJieXRlczMyXCIsIHsgdHlwZTogXCJieXRlczMyXCIgfV0sXG4gIFtcImludFwiLCB7IHR5cGU6IFwiaW50MjU2XCIgfV0sXG4gIFtcImludDI1NlwiLCB7IHR5cGU6IFwiaW50MjU2XCIgfV0sXG4gIFtcInN0cmluZ1wiLCB7IHR5cGU6IFwic3RyaW5nXCIgfV0sXG4gIFtcInVpbnRcIiwgeyB0eXBlOiBcInVpbnQyNTZcIiB9XSxcbiAgW1widWludDhcIiwgeyB0eXBlOiBcInVpbnQ4XCIgfV0sXG4gIFtcInVpbnQxNlwiLCB7IHR5cGU6IFwidWludDE2XCIgfV0sXG4gIFtcInVpbnQyNFwiLCB7IHR5cGU6IFwidWludDI0XCIgfV0sXG4gIFtcInVpbnQzMlwiLCB7IHR5cGU6IFwidWludDMyXCIgfV0sXG4gIFtcInVpbnQ2NFwiLCB7IHR5cGU6IFwidWludDY0XCIgfV0sXG4gIFtcInVpbnQ5NlwiLCB7IHR5cGU6IFwidWludDk2XCIgfV0sXG4gIFtcInVpbnQxMTJcIiwgeyB0eXBlOiBcInVpbnQxMTJcIiB9XSxcbiAgW1widWludDE2MFwiLCB7IHR5cGU6IFwidWludDE2MFwiIH1dLFxuICBbXCJ1aW50MTkyXCIsIHsgdHlwZTogXCJ1aW50MTkyXCIgfV0sXG4gIFtcInVpbnQyNTZcIiwgeyB0eXBlOiBcInVpbnQyNTZcIiB9XSxcbiAgLy8gTmFtZWRcbiAgW1wiYWRkcmVzcyBvd25lclwiLCB7IHR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIm93bmVyXCIgfV0sXG4gIFtcImFkZHJlc3MgdG9cIiwgeyB0eXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJ0b1wiIH1dLFxuICBbXCJib29sIGFwcHJvdmVkXCIsIHsgdHlwZTogXCJib29sXCIsIG5hbWU6IFwiYXBwcm92ZWRcIiB9XSxcbiAgW1wiYnl0ZXMgX2RhdGFcIiwgeyB0eXBlOiBcImJ5dGVzXCIsIG5hbWU6IFwiX2RhdGFcIiB9XSxcbiAgW1wiYnl0ZXMgZGF0YVwiLCB7IHR5cGU6IFwiYnl0ZXNcIiwgbmFtZTogXCJkYXRhXCIgfV0sXG4gIFtcImJ5dGVzIHNpZ25hdHVyZVwiLCB7IHR5cGU6IFwiYnl0ZXNcIiwgbmFtZTogXCJzaWduYXR1cmVcIiB9XSxcbiAgW1wiYnl0ZXMzMiBoYXNoXCIsIHsgdHlwZTogXCJieXRlczMyXCIsIG5hbWU6IFwiaGFzaFwiIH1dLFxuICBbXCJieXRlczMyIHJcIiwgeyB0eXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJyXCIgfV0sXG4gIFtcImJ5dGVzMzIgcm9vdFwiLCB7IHR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBcInJvb3RcIiB9XSxcbiAgW1wiYnl0ZXMzMiBzXCIsIHsgdHlwZTogXCJieXRlczMyXCIsIG5hbWU6IFwic1wiIH1dLFxuICBbXCJzdHJpbmcgbmFtZVwiLCB7IHR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IFwibmFtZVwiIH1dLFxuICBbXCJzdHJpbmcgc3ltYm9sXCIsIHsgdHlwZTogXCJzdHJpbmdcIiwgbmFtZTogXCJzeW1ib2xcIiB9XSxcbiAgW1wic3RyaW5nIHRva2VuVVJJXCIsIHsgdHlwZTogXCJzdHJpbmdcIiwgbmFtZTogXCJ0b2tlblVSSVwiIH1dLFxuICBbXCJ1aW50IHRva2VuSWRcIiwgeyB0eXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJ0b2tlbklkXCIgfV0sXG4gIFtcInVpbnQ4IHZcIiwgeyB0eXBlOiBcInVpbnQ4XCIsIG5hbWU6IFwidlwiIH1dLFxuICBbXCJ1aW50MjU2IGJhbGFuY2VcIiwgeyB0eXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJiYWxhbmNlXCIgfV0sXG4gIFtcInVpbnQyNTYgdG9rZW5JZFwiLCB7IHR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInRva2VuSWRcIiB9XSxcbiAgW1widWludDI1NiB2YWx1ZVwiLCB7IHR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInZhbHVlXCIgfV0sXG4gIC8vIEluZGV4ZWRcbiAgW1xuICAgIFwiZXZlbnQ6YWRkcmVzcyBpbmRleGVkIGZyb21cIixcbiAgICB7IHR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcImZyb21cIiwgaW5kZXhlZDogdHJ1ZSB9XG4gIF0sXG4gIFtcImV2ZW50OmFkZHJlc3MgaW5kZXhlZCB0b1wiLCB7IHR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInRvXCIsIGluZGV4ZWQ6IHRydWUgfV0sXG4gIFtcbiAgICBcImV2ZW50OnVpbnQgaW5kZXhlZCB0b2tlbklkXCIsXG4gICAgeyB0eXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJ0b2tlbklkXCIsIGluZGV4ZWQ6IHRydWUgfVxuICBdLFxuICBbXG4gICAgXCJldmVudDp1aW50MjU2IGluZGV4ZWQgdG9rZW5JZFwiLFxuICAgIHsgdHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwidG9rZW5JZFwiLCBpbmRleGVkOiB0cnVlIH1cbiAgXVxuXSk7XG5cbi8vIHNyYy9odW1hbi1yZWFkYWJsZS9ydW50aW1lL3V0aWxzLnRzXG5mdW5jdGlvbiBwYXJzZVNpZ25hdHVyZShzaWduYXR1cmUsIHN0cnVjdHMgPSB7fSkge1xuICBpZiAoaXNGdW5jdGlvblNpZ25hdHVyZShzaWduYXR1cmUpKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBleGVjRnVuY3Rpb25TaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICBpZiAoIW1hdGNoKVxuICAgICAgdGhyb3cgbmV3IEJhc2VFcnJvcihcIkludmFsaWQgZnVuY3Rpb24gc2lnbmF0dXJlLlwiLCB7XG4gICAgICAgIGRldGFpbHM6IHNpZ25hdHVyZVxuICAgICAgfSk7XG4gICAgY29uc3QgaW5wdXRQYXJhbXMgPSBzcGxpdFBhcmFtZXRlcnMobWF0Y2gucGFyYW1ldGVycyk7XG4gICAgY29uc3QgaW5wdXRzID0gW107XG4gICAgY29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dFBhcmFtcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dExlbmd0aDsgaSsrKSB7XG4gICAgICBpbnB1dHMucHVzaChcbiAgICAgICAgcGFyc2VBYmlQYXJhbWV0ZXIoaW5wdXRQYXJhbXNbaV0sIHtcbiAgICAgICAgICBtb2RpZmllcnM6IGZ1bmN0aW9uTW9kaWZpZXJzLFxuICAgICAgICAgIHN0cnVjdHMsXG4gICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXRzID0gW107XG4gICAgaWYgKG1hdGNoLnJldHVybnMpIHtcbiAgICAgIGNvbnN0IG91dHB1dFBhcmFtcyA9IHNwbGl0UGFyYW1ldGVycyhtYXRjaC5yZXR1cm5zKTtcbiAgICAgIGNvbnN0IG91dHB1dExlbmd0aCA9IG91dHB1dFBhcmFtcy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dExlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dHB1dHMucHVzaChcbiAgICAgICAgICBwYXJzZUFiaVBhcmFtZXRlcihvdXRwdXRQYXJhbXNbaV0sIHtcbiAgICAgICAgICAgIG1vZGlmaWVyczogZnVuY3Rpb25Nb2RpZmllcnMsXG4gICAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG1hdGNoLm5hbWUsXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IG1hdGNoLnN0YXRlTXV0YWJpbGl0eSA/PyBcIm5vbnBheWFibGVcIixcbiAgICAgIGlucHV0cyxcbiAgICAgIG91dHB1dHNcbiAgICB9O1xuICB9XG4gIGlmIChpc0V2ZW50U2lnbmF0dXJlKHNpZ25hdHVyZSkpIHtcbiAgICBjb25zdCBtYXRjaCA9IGV4ZWNFdmVudFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgIGlmICghbWF0Y2gpXG4gICAgICB0aHJvdyBuZXcgQmFzZUVycm9yKFwiSW52YWxpZCBldmVudCBzaWduYXR1cmUuXCIsIHtcbiAgICAgICAgZGV0YWlsczogc2lnbmF0dXJlXG4gICAgICB9KTtcbiAgICBjb25zdCBwYXJhbXMgPSBzcGxpdFBhcmFtZXRlcnMobWF0Y2gucGFyYW1ldGVycyk7XG4gICAgY29uc3QgYWJpUGFyYW1ldGVycyA9IFtdO1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhcmFtcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYWJpUGFyYW1ldGVycy5wdXNoKFxuICAgICAgICBwYXJzZUFiaVBhcmFtZXRlcihwYXJhbXNbaV0sIHtcbiAgICAgICAgICBtb2RpZmllcnM6IGV2ZW50TW9kaWZpZXJzLFxuICAgICAgICAgIHN0cnVjdHMsXG4gICAgICAgICAgdHlwZTogXCJldmVudFwiXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4geyBuYW1lOiBtYXRjaC5uYW1lLCB0eXBlOiBcImV2ZW50XCIsIGlucHV0czogYWJpUGFyYW1ldGVycyB9O1xuICB9XG4gIGlmIChpc0Vycm9yU2lnbmF0dXJlKHNpZ25hdHVyZSkpIHtcbiAgICBjb25zdCBtYXRjaCA9IGV4ZWNFcnJvclNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgIGlmICghbWF0Y2gpXG4gICAgICB0aHJvdyBuZXcgQmFzZUVycm9yKFwiSW52YWxpZCBlcnJvciBzaWduYXR1cmUuXCIsIHtcbiAgICAgICAgZGV0YWlsczogc2lnbmF0dXJlXG4gICAgICB9KTtcbiAgICBjb25zdCBwYXJhbXMgPSBzcGxpdFBhcmFtZXRlcnMobWF0Y2gucGFyYW1ldGVycyk7XG4gICAgY29uc3QgYWJpUGFyYW1ldGVycyA9IFtdO1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhcmFtcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYWJpUGFyYW1ldGVycy5wdXNoKFxuICAgICAgICBwYXJzZUFiaVBhcmFtZXRlcihwYXJhbXNbaV0sIHsgc3RydWN0cywgdHlwZTogXCJlcnJvclwiIH0pXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4geyBuYW1lOiBtYXRjaC5uYW1lLCB0eXBlOiBcImVycm9yXCIsIGlucHV0czogYWJpUGFyYW1ldGVycyB9O1xuICB9XG4gIGlmIChpc0NvbnN0cnVjdG9yU2lnbmF0dXJlKHNpZ25hdHVyZSkpIHtcbiAgICBjb25zdCBtYXRjaCA9IGV4ZWNDb25zdHJ1Y3RvclNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgIGlmICghbWF0Y2gpXG4gICAgICB0aHJvdyBuZXcgQmFzZUVycm9yKFwiSW52YWxpZCBjb25zdHJ1Y3RvciBzaWduYXR1cmUuXCIsIHtcbiAgICAgICAgZGV0YWlsczogc2lnbmF0dXJlXG4gICAgICB9KTtcbiAgICBjb25zdCBwYXJhbXMgPSBzcGxpdFBhcmFtZXRlcnMobWF0Y2gucGFyYW1ldGVycyk7XG4gICAgY29uc3QgYWJpUGFyYW1ldGVycyA9IFtdO1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhcmFtcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYWJpUGFyYW1ldGVycy5wdXNoKFxuICAgICAgICBwYXJzZUFiaVBhcmFtZXRlcihwYXJhbXNbaV0sIHsgc3RydWN0cywgdHlwZTogXCJjb25zdHJ1Y3RvclwiIH0pXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBtYXRjaC5zdGF0ZU11dGFiaWxpdHkgPz8gXCJub25wYXlhYmxlXCIsXG4gICAgICBpbnB1dHM6IGFiaVBhcmFtZXRlcnNcbiAgICB9O1xuICB9XG4gIGlmIChpc0ZhbGxiYWNrU2lnbmF0dXJlKHNpZ25hdHVyZSkpXG4gICAgcmV0dXJuIHsgdHlwZTogXCJmYWxsYmFja1wiIH07XG4gIGlmIChpc1JlY2VpdmVTaWduYXR1cmUoc2lnbmF0dXJlKSlcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJyZWNlaXZlXCIsXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IFwicGF5YWJsZVwiXG4gICAgfTtcbiAgdGhyb3cgbmV3IEJhc2VFcnJvcihcIlVua25vd24gc2lnbmF0dXJlLlwiLCB7XG4gICAgZGV0YWlsczogc2lnbmF0dXJlXG4gIH0pO1xufVxudmFyIGFiaVBhcmFtZXRlcldpdGhvdXRUdXBsZVJlZ2V4ID0gL14oPzx0eXBlPlthLXpBLVowLTlfXSs/KSg/PGFycmF5Pig/OlxcW1xcZCo/XFxdKSs/KT8oPzpcXHMoPzxtb2RpZmllcj5jYWxsZGF0YXxpbmRleGVkfG1lbW9yeXxzdG9yYWdlezF9KSk/KD86XFxzKD88bmFtZT5bYS16QS1aMC05X10rKSk/JC87XG52YXIgYWJpUGFyYW1ldGVyV2l0aFR1cGxlUmVnZXggPSAvXlxcKCg/PHR5cGU+Lis/KVxcKSg/PGFycmF5Pig/OlxcW1xcZCo/XFxdKSs/KT8oPzpcXHMoPzxtb2RpZmllcj5jYWxsZGF0YXxpbmRleGVkfG1lbW9yeXxzdG9yYWdlezF9KSk/KD86XFxzKD88bmFtZT5bYS16QS1aMC05X10rKSk/JC87XG52YXIgZHluYW1pY0ludGVnZXJSZWdleCA9IC9edT9pbnQkLztcbmZ1bmN0aW9uIHBhcnNlQWJpUGFyYW1ldGVyKHBhcmFtLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhcmFtZXRlckNhY2hlS2V5ID0gZ2V0UGFyYW1ldGVyQ2FjaGVLZXkocGFyYW0sIG9wdGlvbnM/LnR5cGUpO1xuICBpZiAocGFyYW1ldGVyQ2FjaGUuaGFzKHBhcmFtZXRlckNhY2hlS2V5KSlcbiAgICByZXR1cm4gcGFyYW1ldGVyQ2FjaGUuZ2V0KHBhcmFtZXRlckNhY2hlS2V5KTtcbiAgY29uc3QgaXNUdXBsZSA9IGlzVHVwbGVSZWdleC50ZXN0KHBhcmFtKTtcbiAgY29uc3QgbWF0Y2ggPSBleGVjVHlwZWQoXG4gICAgaXNUdXBsZSA/IGFiaVBhcmFtZXRlcldpdGhUdXBsZVJlZ2V4IDogYWJpUGFyYW1ldGVyV2l0aG91dFR1cGxlUmVnZXgsXG4gICAgcGFyYW1cbiAgKTtcbiAgaWYgKCFtYXRjaClcbiAgICB0aHJvdyBuZXcgQmFzZUVycm9yKFwiSW52YWxpZCBBQkkgcGFyYW1ldGVyLlwiLCB7XG4gICAgICBkZXRhaWxzOiBwYXJhbVxuICAgIH0pO1xuICBpZiAobWF0Y2gubmFtZSAmJiBpc1NvbGlkaXR5S2V5d29yZChtYXRjaC5uYW1lKSlcbiAgICB0aHJvdyBuZXcgQmFzZUVycm9yKFwiSW52YWxpZCBBQkkgcGFyYW1ldGVyLlwiLCB7XG4gICAgICBkZXRhaWxzOiBwYXJhbSxcbiAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICBgXCIke21hdGNoLm5hbWV9XCIgaXMgYSBwcm90ZWN0ZWQgU29saWRpdHkga2V5d29yZC4gTW9yZSBpbmZvOiBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi9sYXRlc3QvY2hlYXRzaGVldC5odG1sYFxuICAgICAgXVxuICAgIH0pO1xuICBjb25zdCBuYW1lMiA9IG1hdGNoLm5hbWUgPyB7IG5hbWU6IG1hdGNoLm5hbWUgfSA6IHt9O1xuICBjb25zdCBpbmRleGVkID0gbWF0Y2gubW9kaWZpZXIgPT09IFwiaW5kZXhlZFwiID8geyBpbmRleGVkOiB0cnVlIH0gOiB7fTtcbiAgY29uc3Qgc3RydWN0cyA9IG9wdGlvbnM/LnN0cnVjdHMgPz8ge307XG4gIGxldCB0eXBlO1xuICBsZXQgY29tcG9uZW50cyA9IHt9O1xuICBpZiAoaXNUdXBsZSkge1xuICAgIHR5cGUgPSBcInR1cGxlXCI7XG4gICAgY29uc3QgcGFyYW1zID0gc3BsaXRQYXJhbWV0ZXJzKG1hdGNoLnR5cGUpO1xuICAgIGNvbnN0IGNvbXBvbmVudHNfID0gW107XG4gICAgY29uc3QgbGVuZ3RoID0gcGFyYW1zLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb21wb25lbnRzXy5wdXNoKHBhcnNlQWJpUGFyYW1ldGVyKHBhcmFtc1tpXSwgeyBzdHJ1Y3RzIH0pKTtcbiAgICB9XG4gICAgY29tcG9uZW50cyA9IHsgY29tcG9uZW50czogY29tcG9uZW50c18gfTtcbiAgfSBlbHNlIGlmIChtYXRjaC50eXBlIGluIHN0cnVjdHMpIHtcbiAgICB0eXBlID0gXCJ0dXBsZVwiO1xuICAgIGNvbXBvbmVudHMgPSB7IGNvbXBvbmVudHM6IHN0cnVjdHNbbWF0Y2gudHlwZV0gfTtcbiAgfSBlbHNlIGlmIChkeW5hbWljSW50ZWdlclJlZ2V4LnRlc3QobWF0Y2gudHlwZSkpIHtcbiAgICB0eXBlID0gYCR7bWF0Y2gudHlwZX0yNTZgO1xuICB9IGVsc2Uge1xuICAgIHR5cGUgPSBtYXRjaC50eXBlO1xuICAgIGlmICghKG9wdGlvbnM/LnR5cGUgPT09IFwic3RydWN0XCIpICYmICFpc1NvbGlkaXR5VHlwZSh0eXBlKSlcbiAgICAgIHRocm93IG5ldyBCYXNlRXJyb3IoXCJVbmtub3duIHR5cGUuXCIsIHtcbiAgICAgICAgbWV0YU1lc3NhZ2VzOiBbYFR5cGUgXCIke3R5cGV9XCIgaXMgbm90IGEgdmFsaWQgQUJJIHR5cGUuYF1cbiAgICAgIH0pO1xuICB9XG4gIGlmIChtYXRjaC5tb2RpZmllcikge1xuICAgIGlmICghb3B0aW9ucz8ubW9kaWZpZXJzPy5oYXM/LihtYXRjaC5tb2RpZmllcikpXG4gICAgICB0aHJvdyBuZXcgQmFzZUVycm9yKFwiSW52YWxpZCBBQkkgcGFyYW1ldGVyLlwiLCB7XG4gICAgICAgIGRldGFpbHM6IHBhcmFtLFxuICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICBgTW9kaWZpZXIgXCIke21hdGNoLm1vZGlmaWVyfVwiIG5vdCBhbGxvd2VkJHtvcHRpb25zPy50eXBlID8gYCBpbiBcIiR7b3B0aW9ucy50eXBlfVwiIHR5cGVgIDogXCJcIn0uYFxuICAgICAgICBdXG4gICAgICB9KTtcbiAgICBpZiAoZnVuY3Rpb25Nb2RpZmllcnMuaGFzKG1hdGNoLm1vZGlmaWVyKSAmJiAhaXNWYWxpZERhdGFMb2NhdGlvbih0eXBlLCAhIW1hdGNoLmFycmF5KSlcbiAgICAgIHRocm93IG5ldyBCYXNlRXJyb3IoXCJJbnZhbGlkIEFCSSBwYXJhbWV0ZXIuXCIsIHtcbiAgICAgICAgZGV0YWlsczogcGFyYW0sXG4gICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgIGBNb2RpZmllciBcIiR7bWF0Y2gubW9kaWZpZXJ9XCIgbm90IGFsbG93ZWQke29wdGlvbnM/LnR5cGUgPyBgIGluIFwiJHtvcHRpb25zLnR5cGV9XCIgdHlwZWAgOiBcIlwifS5gLFxuICAgICAgICAgIGBEYXRhIGxvY2F0aW9uIGNhbiBvbmx5IGJlIHNwZWNpZmllZCBmb3IgYXJyYXksIHN0cnVjdCwgb3IgbWFwcGluZyB0eXBlcywgYnV0IFwiJHttYXRjaC5tb2RpZmllcn1cIiB3YXMgZ2l2ZW4uYFxuICAgICAgICBdXG4gICAgICB9KTtcbiAgfVxuICBjb25zdCBhYmlQYXJhbWV0ZXIgPSB7XG4gICAgdHlwZTogYCR7dHlwZX0ke21hdGNoLmFycmF5ID8/IFwiXCJ9YCxcbiAgICAuLi5uYW1lMixcbiAgICAuLi5pbmRleGVkLFxuICAgIC4uLmNvbXBvbmVudHNcbiAgfTtcbiAgcGFyYW1ldGVyQ2FjaGUuc2V0KHBhcmFtZXRlckNhY2hlS2V5LCBhYmlQYXJhbWV0ZXIpO1xuICByZXR1cm4gYWJpUGFyYW1ldGVyO1xufVxuZnVuY3Rpb24gc3BsaXRQYXJhbWV0ZXJzKHBhcmFtcywgcmVzdWx0ID0gW10sIGN1cnJlbnQgPSBcIlwiLCBkZXB0aCA9IDApIHtcbiAgaWYgKHBhcmFtcyA9PT0gXCJcIikge1xuICAgIGlmIChjdXJyZW50ID09PSBcIlwiKVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoZGVwdGggIT09IDApXG4gICAgICB0aHJvdyBuZXcgQmFzZUVycm9yKFwiVW5iYWxhbmNlZCBwYXJlbnRoZXNlcy5cIiwge1xuICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICBgXCIke2N1cnJlbnQudHJpbSgpfVwiIGhhcyB0b28gbWFueSAke2RlcHRoID4gMCA/IFwib3BlbmluZ1wiIDogXCJjbG9zaW5nXCJ9IHBhcmVudGhlc2VzLmBcbiAgICAgICAgXSxcbiAgICAgICAgZGV0YWlsczogYERlcHRoIFwiJHtkZXB0aH1cImBcbiAgICAgIH0pO1xuICAgIHJldHVybiBbLi4ucmVzdWx0LCBjdXJyZW50LnRyaW0oKV07XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gcGFyYW1zLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBwYXJhbXNbaV07XG4gICAgY29uc3QgdGFpbCA9IHBhcmFtcy5zbGljZShpICsgMSk7XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICBjYXNlIFwiLFwiOlxuICAgICAgICByZXR1cm4gZGVwdGggPT09IDAgPyBzcGxpdFBhcmFtZXRlcnModGFpbCwgWy4uLnJlc3VsdCwgY3VycmVudC50cmltKCldKSA6IHNwbGl0UGFyYW1ldGVycyh0YWlsLCByZXN1bHQsIGAke2N1cnJlbnR9JHtjaGFyfWAsIGRlcHRoKTtcbiAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgIHJldHVybiBzcGxpdFBhcmFtZXRlcnModGFpbCwgcmVzdWx0LCBgJHtjdXJyZW50fSR7Y2hhcn1gLCBkZXB0aCArIDEpO1xuICAgICAgY2FzZSBcIilcIjpcbiAgICAgICAgcmV0dXJuIHNwbGl0UGFyYW1ldGVycyh0YWlsLCByZXN1bHQsIGAke2N1cnJlbnR9JHtjaGFyfWAsIGRlcHRoIC0gMSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3BsaXRQYXJhbWV0ZXJzKHRhaWwsIHJlc3VsdCwgYCR7Y3VycmVudH0ke2NoYXJ9YCwgZGVwdGgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBpc1NvbGlkaXR5VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlID09PSBcImFkZHJlc3NcIiB8fCB0eXBlID09PSBcImJvb2xcIiB8fCB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBieXRlc1JlZ2V4LnRlc3QodHlwZSkgfHwgaW50ZWdlclJlZ2V4LnRlc3QodHlwZSk7XG59XG52YXIgcHJvdGVjdGVkS2V5d29yZHNSZWdleCA9IC9eKD86YWZ0ZXJ8YWxpYXN8YW5vbnltb3VzfGFwcGx5fGF1dG98Ynl0ZXxjYWxsZGF0YXxjYXNlfGNhdGNofGNvbnN0YW50fGNvcHlvZnxkZWZhdWx0fGRlZmluZWR8ZXJyb3J8ZXZlbnR8ZXh0ZXJuYWx8ZmFsc2V8ZmluYWx8ZnVuY3Rpb258aW1tdXRhYmxlfGltcGxlbWVudHN8aW58aW5kZXhlZHxpbmxpbmV8aW50ZXJuYWx8bGV0fG1hcHBpbmd8bWF0Y2h8bWVtb3J5fG11dGFibGV8bnVsbHxvZnxvdmVycmlkZXxwYXJ0aWFsfHByaXZhdGV8cHJvbWlzZXxwdWJsaWN8cHVyZXxyZWZlcmVuY2V8cmVsb2NhdGFibGV8cmV0dXJufHJldHVybnN8c2l6ZW9mfHN0YXRpY3xzdG9yYWdlfHN0cnVjdHxzdXBlcnxzdXBwb3J0c3xzd2l0Y2h8dGhpc3x0cnVlfHRyeXx0eXBlZGVmfHR5cGVvZnx2YXJ8dmlld3x2aXJ0dWFsKSQvO1xuZnVuY3Rpb24gaXNTb2xpZGl0eUtleXdvcmQobmFtZTIpIHtcbiAgcmV0dXJuIG5hbWUyID09PSBcImFkZHJlc3NcIiB8fCBuYW1lMiA9PT0gXCJib29sXCIgfHwgbmFtZTIgPT09IFwiZnVuY3Rpb25cIiB8fCBuYW1lMiA9PT0gXCJzdHJpbmdcIiB8fCBuYW1lMiA9PT0gXCJ0dXBsZVwiIHx8IGJ5dGVzUmVnZXgudGVzdChuYW1lMikgfHwgaW50ZWdlclJlZ2V4LnRlc3QobmFtZTIpIHx8IHByb3RlY3RlZEtleXdvcmRzUmVnZXgudGVzdChuYW1lMik7XG59XG5mdW5jdGlvbiBpc1ZhbGlkRGF0YUxvY2F0aW9uKHR5cGUsIGlzQXJyYXkpIHtcbiAgcmV0dXJuIGlzQXJyYXkgfHwgdHlwZSA9PT0gXCJieXRlc1wiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJ0dXBsZVwiO1xufVxuXG4vLyBzcmMvaHVtYW4tcmVhZGFibGUvcnVudGltZS9zdHJ1Y3RzLnRzXG5mdW5jdGlvbiBwYXJzZVN0cnVjdHMoc2lnbmF0dXJlcykge1xuICBjb25zdCBzaGFsbG93U3RydWN0cyA9IHt9O1xuICBjb25zdCBzaWduYXR1cmVzTGVuZ3RoID0gc2lnbmF0dXJlcy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmF0dXJlc0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbmF0dXJlc1tpXTtcbiAgICBpZiAoIWlzU3RydWN0U2lnbmF0dXJlKHNpZ25hdHVyZSkpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBtYXRjaCA9IGV4ZWNTdHJ1Y3RTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICBpZiAoIW1hdGNoKVxuICAgICAgdGhyb3cgbmV3IEJhc2VFcnJvcihcIkludmFsaWQgc3RydWN0IHNpZ25hdHVyZS5cIiwge1xuICAgICAgICBkZXRhaWxzOiBzaWduYXR1cmVcbiAgICAgIH0pO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBtYXRjaC5wcm9wZXJ0aWVzLnNwbGl0KFwiO1wiKTtcbiAgICBjb25zdCBjb21wb25lbnRzID0gW107XG4gICAgY29uc3QgcHJvcGVydGllc0xlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcHJvcGVydGllc0xlbmd0aDsgaysrKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IHByb3BlcnRpZXNba107XG4gICAgICBjb25zdCB0cmltbWVkID0gcHJvcGVydHkudHJpbSgpO1xuICAgICAgaWYgKCF0cmltbWVkKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGFiaVBhcmFtZXRlciA9IHBhcnNlQWJpUGFyYW1ldGVyKHRyaW1tZWQsIHtcbiAgICAgICAgdHlwZTogXCJzdHJ1Y3RcIlxuICAgICAgfSk7XG4gICAgICBjb21wb25lbnRzLnB1c2goYWJpUGFyYW1ldGVyKTtcbiAgICB9XG4gICAgaWYgKCFjb21wb25lbnRzLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBCYXNlRXJyb3IoXCJJbnZhbGlkIHN0cnVjdCBzaWduYXR1cmUuXCIsIHtcbiAgICAgICAgZGV0YWlsczogc2lnbmF0dXJlLFxuICAgICAgICBtZXRhTWVzc2FnZXM6IFtcIk5vIHByb3BlcnRpZXMgZXhpc3QuXCJdXG4gICAgICB9KTtcbiAgICBzaGFsbG93U3RydWN0c1ttYXRjaC5uYW1lXSA9IGNvbXBvbmVudHM7XG4gIH1cbiAgY29uc3QgcmVzb2x2ZWRTdHJ1Y3RzID0ge307XG4gIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhzaGFsbG93U3RydWN0cyk7XG4gIGNvbnN0IGVudHJpZXNMZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBbbmFtZTIsIHBhcmFtZXRlcnNdID0gZW50cmllc1tpXTtcbiAgICByZXNvbHZlZFN0cnVjdHNbbmFtZTJdID0gcmVzb2x2ZVN0cnVjdHMocGFyYW1ldGVycywgc2hhbGxvd1N0cnVjdHMpO1xuICB9XG4gIHJldHVybiByZXNvbHZlZFN0cnVjdHM7XG59XG52YXIgdHlwZVdpdGhvdXRUdXBsZVJlZ2V4ID0gL14oPzx0eXBlPlthLXpBLVowLTlfXSs/KSg/PGFycmF5Pig/OlxcW1xcZCo/XFxdKSs/KT8kLztcbmZ1bmN0aW9uIHJlc29sdmVTdHJ1Y3RzKGFiaVBhcmFtZXRlcnMsIHN0cnVjdHMsIGFuY2VzdG9ycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpIHtcbiAgY29uc3QgY29tcG9uZW50cyA9IFtdO1xuICBjb25zdCBsZW5ndGggPSBhYmlQYXJhbWV0ZXJzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFiaVBhcmFtZXRlciA9IGFiaVBhcmFtZXRlcnNbaV07XG4gICAgY29uc3QgaXNUdXBsZSA9IGlzVHVwbGVSZWdleC50ZXN0KGFiaVBhcmFtZXRlci50eXBlKTtcbiAgICBpZiAoaXNUdXBsZSlcbiAgICAgIGNvbXBvbmVudHMucHVzaChhYmlQYXJhbWV0ZXIpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbWF0Y2ggPSBleGVjVHlwZWQoXG4gICAgICAgIHR5cGVXaXRob3V0VHVwbGVSZWdleCxcbiAgICAgICAgYWJpUGFyYW1ldGVyLnR5cGVcbiAgICAgICk7XG4gICAgICBpZiAoIW1hdGNoPy50eXBlKVxuICAgICAgICB0aHJvdyBuZXcgQmFzZUVycm9yKFwiSW52YWxpZCBBQkkgcGFyYW1ldGVyLlwiLCB7XG4gICAgICAgICAgZGV0YWlsczogSlNPTi5zdHJpbmdpZnkoYWJpUGFyYW1ldGVyLCBudWxsLCAyKSxcbiAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcIkFCSSBwYXJhbWV0ZXIgdHlwZSBpcyBpbnZhbGlkLlwiXVxuICAgICAgICB9KTtcbiAgICAgIGNvbnN0IHsgYXJyYXksIHR5cGUgfSA9IG1hdGNoO1xuICAgICAgaWYgKHR5cGUgaW4gc3RydWN0cykge1xuICAgICAgICBpZiAoYW5jZXN0b3JzLmhhcyh0eXBlKSlcbiAgICAgICAgICB0aHJvdyBuZXcgQmFzZUVycm9yKFwiQ2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGVkLlwiLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtgU3RydWN0IFwiJHt0eXBlfVwiIGlzIGEgY2lyY3VsYXIgcmVmZXJlbmNlLmBdXG4gICAgICAgICAgfSk7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh7XG4gICAgICAgICAgLi4uYWJpUGFyYW1ldGVyLFxuICAgICAgICAgIHR5cGU6IGB0dXBsZSR7YXJyYXkgPz8gXCJcIn1gLFxuICAgICAgICAgIGNvbXBvbmVudHM6IHJlc29sdmVTdHJ1Y3RzKFxuICAgICAgICAgICAgc3RydWN0c1t0eXBlXSA/PyBbXSxcbiAgICAgICAgICAgIHN0cnVjdHMsXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4uYW5jZXN0b3JzLCB0eXBlXSlcbiAgICAgICAgICApXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzU29saWRpdHlUeXBlKHR5cGUpKVxuICAgICAgICAgIGNvbXBvbmVudHMucHVzaChhYmlQYXJhbWV0ZXIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgbmV3IEJhc2VFcnJvcihcIlVua25vd24gdHlwZS5cIiwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgIGBUeXBlIFwiJHt0eXBlfVwiIGlzIG5vdCBhIHZhbGlkIEFCSSB0eXBlLiBQZXJoYXBzIHlvdSBmb3Jnb3QgdG8gaW5jbHVkZSBhIHN0cnVjdCBzaWduYXR1cmU/YFxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcG9uZW50cztcbn1cblxuLy8gc3JjL2h1bWFuLXJlYWRhYmxlL3BhcnNlQWJpLnRzXG5mdW5jdGlvbiBwYXJzZUFiaShzaWduYXR1cmVzKSB7XG4gIGNvbnN0IHN0cnVjdHMgPSBwYXJzZVN0cnVjdHMoc2lnbmF0dXJlcyk7XG4gIGNvbnN0IGFiaSA9IFtdO1xuICBjb25zdCBsZW5ndGggPSBzaWduYXR1cmVzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ25hdHVyZXNbaV07XG4gICAgaWYgKGlzU3RydWN0U2lnbmF0dXJlKHNpZ25hdHVyZSkpXG4gICAgICBjb250aW51ZTtcbiAgICBhYmkucHVzaChwYXJzZVNpZ25hdHVyZShzaWduYXR1cmUsIHN0cnVjdHMpKTtcbiAgfVxuICByZXR1cm4gYWJpO1xufVxuXG4vLyBzcmMvaHVtYW4tcmVhZGFibGUvcGFyc2VBYmlJdGVtLnRzXG5mdW5jdGlvbiBwYXJzZUFiaUl0ZW0oc2lnbmF0dXJlKSB7XG4gIGxldCBhYmlJdGVtO1xuICBpZiAodHlwZW9mIHNpZ25hdHVyZSA9PT0gXCJzdHJpbmdcIilcbiAgICBhYmlJdGVtID0gcGFyc2VTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgZWxzZSB7XG4gICAgY29uc3Qgc3RydWN0cyA9IHBhcnNlU3RydWN0cyhzaWduYXR1cmUpO1xuICAgIGNvbnN0IGxlbmd0aCA9IHNpZ25hdHVyZS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2lnbmF0dXJlXyA9IHNpZ25hdHVyZVtpXTtcbiAgICAgIGlmIChpc1N0cnVjdFNpZ25hdHVyZShzaWduYXR1cmVfKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBhYmlJdGVtID0gcGFyc2VTaWduYXR1cmUoc2lnbmF0dXJlXywgc3RydWN0cyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKCFhYmlJdGVtKVxuICAgIHRocm93IG5ldyBCYXNlRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgQUJJIGl0ZW0uXCIsIHtcbiAgICAgIGRldGFpbHM6IGBwYXJzZUFiaUl0ZW0oJHtKU09OLnN0cmluZ2lmeShzaWduYXR1cmUsIG51bGwsIDIpfSlgLFxuICAgICAgZG9jc1BhdGg6IFwiL2FwaS9odW1hbi5odG1sI3BhcnNlYWJpaXRlbS0xXCJcbiAgICB9KTtcbiAgcmV0dXJuIGFiaUl0ZW07XG59XG5cbi8vIHNyYy9odW1hbi1yZWFkYWJsZS9wYXJzZUFiaVBhcmFtZXRlci50c1xuZnVuY3Rpb24gcGFyc2VBYmlQYXJhbWV0ZXIyKHBhcmFtKSB7XG4gIGxldCBhYmlQYXJhbWV0ZXI7XG4gIGlmICh0eXBlb2YgcGFyYW0gPT09IFwic3RyaW5nXCIpXG4gICAgYWJpUGFyYW1ldGVyID0gcGFyc2VBYmlQYXJhbWV0ZXIocGFyYW0sIHtcbiAgICAgIG1vZGlmaWVyc1xuICAgIH0pO1xuICBlbHNlIHtcbiAgICBjb25zdCBzdHJ1Y3RzID0gcGFyc2VTdHJ1Y3RzKHBhcmFtKTtcbiAgICBjb25zdCBsZW5ndGggPSBwYXJhbS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gcGFyYW1baV07XG4gICAgICBpZiAoaXNTdHJ1Y3RTaWduYXR1cmUoc2lnbmF0dXJlKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBhYmlQYXJhbWV0ZXIgPSBwYXJzZUFiaVBhcmFtZXRlcihzaWduYXR1cmUsIHsgbW9kaWZpZXJzLCBzdHJ1Y3RzIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICghYWJpUGFyYW1ldGVyKVxuICAgIHRocm93IG5ldyBCYXNlRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgQUJJIHBhcmFtZXRlci5cIiwge1xuICAgICAgZGV0YWlsczogYHBhcnNlQWJpUGFyYW1ldGVyKCR7SlNPTi5zdHJpbmdpZnkocGFyYW0sIG51bGwsIDIpfSlgLFxuICAgICAgZG9jc1BhdGg6IFwiL2FwaS9odW1hbi5odG1sI3BhcnNlYWJpcGFyYW1ldGVyLTFcIlxuICAgIH0pO1xuICByZXR1cm4gYWJpUGFyYW1ldGVyO1xufVxuXG4vLyBzcmMvaHVtYW4tcmVhZGFibGUvcGFyc2VBYmlQYXJhbWV0ZXJzLnRzXG5mdW5jdGlvbiBwYXJzZUFiaVBhcmFtZXRlcnMocGFyYW1zKSB7XG4gIGNvbnN0IGFiaVBhcmFtZXRlcnMgPSBbXTtcbiAgaWYgKHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gc3BsaXRQYXJhbWV0ZXJzKHBhcmFtcyk7XG4gICAgY29uc3QgbGVuZ3RoID0gcGFyYW1ldGVycy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYWJpUGFyYW1ldGVycy5wdXNoKHBhcnNlQWJpUGFyYW1ldGVyKHBhcmFtZXRlcnNbaV0sIHsgbW9kaWZpZXJzIH0pKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc3RydWN0cyA9IHBhcnNlU3RydWN0cyhwYXJhbXMpO1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhcmFtcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gcGFyYW1zW2ldO1xuICAgICAgaWYgKGlzU3RydWN0U2lnbmF0dXJlKHNpZ25hdHVyZSkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHNwbGl0UGFyYW1ldGVycyhzaWduYXR1cmUpO1xuICAgICAgY29uc3QgbGVuZ3RoMiA9IHBhcmFtZXRlcnMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBsZW5ndGgyOyBrKyspIHtcbiAgICAgICAgYWJpUGFyYW1ldGVycy5wdXNoKFxuICAgICAgICAgIHBhcnNlQWJpUGFyYW1ldGVyKHBhcmFtZXRlcnNba10sIHsgbW9kaWZpZXJzLCBzdHJ1Y3RzIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChhYmlQYXJhbWV0ZXJzLmxlbmd0aCA9PT0gMClcbiAgICB0aHJvdyBuZXcgQmFzZUVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIEFCSSBwYXJhbWV0ZXJzLlwiLCB7XG4gICAgICBkZXRhaWxzOiBgcGFyc2VBYmlQYXJhbWV0ZXJzKCR7SlNPTi5zdHJpbmdpZnkocGFyYW1zLCBudWxsLCAyKX0pYCxcbiAgICAgIGRvY3NQYXRoOiBcIi9hcGkvaHVtYW4uaHRtbCNwYXJzZWFiaXBhcmFtZXRlcnMtMVwiXG4gICAgfSk7XG4gIHJldHVybiBhYmlQYXJhbWV0ZXJzO1xufVxuZXhwb3J0IHtcbiAgQmFzZUVycm9yLFxuICBuYXJyb3csXG4gIHBhcnNlQWJpLFxuICBwYXJzZUFiaUl0ZW0sXG4gIHBhcnNlQWJpUGFyYW1ldGVyMiBhcyBwYXJzZUFiaVBhcmFtZXRlcixcbiAgcGFyc2VBYmlQYXJhbWV0ZXJzXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/abitype/dist/index.mjs\n");

/***/ })

};
;